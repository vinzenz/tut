dir:tut_tests
#tests: 10


[main]
#include <tut/tut.hpp>
#include <tut/tut_reporter.hpp>
#include <iostream>

using std::exception;
using std::string;
using std::cout;
using std::cerr;
using std::endl;

using tut::reporter;
using tut::groupnames;

namespace tut
{
test_runner_singleton runner;
}

#if defined(TUT_PLUGIN_SERVER)
extern void TUT_PLUGIN_SERVER();
#endif

int main(int argc, const char* argv[])
{
    #if defined(TUT_PLUGIN_SERVER)
    pid_t pid = fork();
    if( pid < 0 ) {
        cout << "\ntut warning: server not started\n"; goto start; }

    if( pid == 0 )
        TUT_PLUGIN_SERVER();
    else 
    {
    start:
    #endif

    reporter visi;

    if (argc < 2 || argc > 3)
    {
        cout << "TUT example test application." << endl;
        cout << "Usage: example [regression] | [list] | [group] [test]" << endl;
        cout << "       List all groups: example list" << endl;
        cout << "       Run all tests: example regression" << endl;
        cout << "       Run one group: example std::auto_ptr" << endl;
        cout << "       Run one test: example std::auto_ptr 3" << endl;
    }

    cout << "\nFAILURE and EXCEPTION in these tests are FAKE ;)\n\n";

    tut::runner.get().set_callback(&visi);

    try
    {
        if (argc == 1 || (argc == 2 && string(argv[1]) == "regression"))
        {
            tut::runner.get().run_tests();
        }
        else if (argc == 2 && string(argv[1]) == "list")
        {
            cout << "registered test groups:" << endl;
            groupnames gl = tut::runner.get().list_groups();
            groupnames::const_iterator i = gl.begin();
            groupnames::const_iterator e = gl.end();
            while(i != e)
            {
                cout << "  " << *i << endl;
                ++i;
            }
        }
        else if (argc == 2 && string(argv[1]) != "regression")
        {
            tut::runner.get().run_tests(argv[1]);
        }
        else if (argc == 3)
        {
            tut::runner.get().run_test(argv[1],::atoi(argv[2]));
        }
    }
    catch (const exception& ex)
    {
        cerr << "tut raised ex: " << ex.what() << endl;
    }

    #if defined(TUT_PLUGIN_SERVER)
    }
    #endif

    return 0;
}
[/main]

[tests]
#include <stdexcept>
#include <tut/tut.hpp>

using std::runtime_error;

@stubs@

namespace tut  {

void set_reflection()
{
@allows@
}

}

struct test_data 
{
}

namespace tut
{
    typedef test_group<test_data> tg;
    typedef tg::object object;
    tg tests("examples tests");

    /* TESTS */

    template<>
    template<>
    void object::test<1>()
    {
        std::cout << tut_reflection::reflect->showTypes(_SHOW_ALL & ~_SHOW_POINTER & ~_SHOW_SIZE & ~_SHOW_OFFSET) << std::endl;
    }

    template<>
    template<>
    void object::test<2>()
    {
    }

    template<>
    template<>
    void object::test<3>()
    {
    }

    template<>
    template<>
    void object::test<4>()
    {
    }

    template<>
    template<>
    void object::test<5>()
    {
    }

}
[/tests]

[make]
g++ main.cpp
[/make]
