---
title: FAQ
desc: frequently asked questions
---

{menu: {start_level: 2}}

How about test fixtures (setUp/tearDown methods)?
-------------------------------------------------

To aquire resources before the test and to release them right after the test 
use constructor and destructor of the data structure:

{coderay:: c}
// ...
struct complex_data 
{ 
    connection* con;
    complex_data() { con = db_pool.get_connection(); } 
    ~complex_data() { db_pool.release_connection(con); } 
};

template<> 
template<> 
void testobject::test<1>() 
{ 
    // ...
    con->commit();
}
{coderay}

Each test in the group from now on will have the connection initialized by 
constructor and released in destructor.

What would happen if the constructor throws an exception? TUT will treat it as if test itself
failed with an exception. The test body won't be executed and it will be reported as failed with
exception. But the destructor of the data structure will be executed anyway!

An exception in the destructor is threated differently though. Reaching destruction phase means
that the *test itself* has finished successfuly. In this case TUT marks 
the test with a warning status.

Is it possible to have more 50 tests per group?
-----------------------------------------------

Yes. A newly created group has a predefined set of dummy tests (i.e. test placeholders).
By default, there are 50 tests in a group. To create a test group with a higher 
volume (e.g. when tests are generated by a script) provide a higher border of 
test group size when it is instantiated: 

{coderay:: c}
// test group with maximum 500 tests 
typedef test_group<huge_test_data,500> testgroup;
{coderay}

Note that your compiler would possibly need a command-line switch or pragma to enlarge
the recursive instantiation depth. For g++, for example, you should specify --ftemplate-depth-501
to make example above compile. Please consult your compiler's documentation. 

